#####  * 6个false

- false NaN "" null 0 undefined





#### 树

- 二叉树

  - ![二叉树](C:\Users\zaven\Desktop\双师软件\web\code\3-25\练习和作业\二叉树.png)

  - 一棵深度为k,至少有2^(k-1)个叶子结点，至多有2^k - 1个结点。

    有 空二叉树 只有A没有BCD一下

    ​    只有一个根结点的二叉树 只有A点

    只有左子树  A 和 B

    只有右子树  A 和 C

    完全二叉树 A有B C  , B C有DEFG





![红黑树](C:\Users\zaven\Desktop\双师软件\web\code\3-25\练习和作业\红黑树.jpg)



- 红黑树

  ​	红黑树是每个节点都带有颜色属性的二叉查找树，颜色或红色或黑色。

  ​	性质1. 节点是红色或黑色

  ​	性质2. 根节点是黑色

  ​	性质3.所有叶子都是黑色

  ​	性质4. 每个红色节点的两个子节点都是黑色

  ​	性质5.. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点







- 霍夫曼树 : 又称为最优二叉树
  - 其主要作用在于数据压缩和编码长度的优化
  - 给定n个权值作为n个叶子结点，构造一棵二叉树，若带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为霍夫曼树(Huffman Tree)。

![霍夫曼树](C:\Users\zaven\Desktop\双师软件\web\code\3-25\练习和作业\霍夫曼树.png)



 叶子结点为A、B、C、D，对应权值分别为7、5、2、4。

 WPL : 树的所有叶结点的带权路径长度之和，称为树的带权路径长度表示为*WPL*。    3.1.a树的WPL = 7   * 2 + 5 * 2 + 2 * 2 + 4 * 2 = 36

 3.1.b树的WPL = 7 * 1 + 5 * 2 + 2 * 3 + 4 * 3 = 35
 由ABCD构成叶子结点的二叉树形态有许多种，但是WPL最小的树只有3.1.b所示的形态。则3.1.b树为一棵霍夫曼树。

先基础了解



### 主观题

+ i++ 效率高一些还是 ++i 效率高一些? 为什么?

  - i++ ：先引用后增加     先在i所在的表达式中使用i的当前值，后让i加1

  - ++i ：先增加后引用     让i先加1，然后在i所在的表达式中使用i的新值

    - ```javascript
      int x=y=0;
       y = x++; //执行后y的值仍为 0;
      
      int x=y=0;
       y = ++x; //执行后y的值则为 1;
      ```

      例2：条件判断

      ```javascript
       int x=0;
       if( x++ == 1) {} //条件为假
      
      int x = 0;
       if( ++x == 1) {}//条件为真
      ```

       例3：在for循环中++i跟i++有区别吗？

      没有区别，for( ; ; )第2个分号后面的语句是在每次循环结束后执行的，相当于一个独立的语句。

      ```javascript
       for (int i = 0; i < 1024; i++) 
       {  a = 0 ;  }
       //相当于 
       for (int i = 0; i < 1024; ) 
       {  a = 0 ;   i++;  }
      //----------------------------------------------
      for (int i = 0; i < 1024; ++i) 
       {  a = 0 ; }
       //相当于 
       for (int i = 0; i < 1024; ) 
       {  a = 0 ;  ++i ;  }
      ```

      在这里，因为i++与++i等效，因此没有区别。

    - 效率

      ​	i++; // 有一个临时变量 
      ​    ++i; // 无临时变量

      i++由于是在使用当前值之后再+1，所以会需要一个临时变量来转储，而++则直接+1，不存在这样的问题。

